Summary

A standard protocol to encode Solana transaction requests within URLs to enable payments and other use cases.

Rough consensus on this spec has been reached, and implementations exist in Phantom, FTX, and Slope.

This standard draws inspiration from BIP 21 and EIP 681.
Motivation

A standard URL protocol for requesting native SOL transfers, SPL Token transfers, and Solana transactions allows for a better user experience across apps and wallets in the Solana ecosystem.

These URLs may be encoded in QR codes or NFC tags, or sent between users and applications to request payment and compose transactions.

Applications should ensure that a transaction has been confirmed and is valid before they release goods or services being sold, or grant access to objects or events.

Mobile wallets should register to handle the URL scheme to provide a seamless yet secure experience when Solana Pay URLs are encountered in the environment.

By standardizing a simple approach to solving these problems, we ensure basic compatibility of applications and wallets so developers can focus on higher level abstractions.
Specification: Transfer Request

A Solana Pay transfer request URL describes a non-interactive request for a SOL or SPL Token transfer.

solana:<recipient>
      ?amount=<amount>
      &spl-token=<spl-token>
      &reference=<reference>
      &label=<label>
      &message=<message>
      &memo=<memo>

The request is non-interactive because the parameters in the URL are used by a wallet to directly compose a transaction.
Recipient

A single recipient field is required as the pathname. The value must be the base58-encoded public key of a native SOL account. Associated token accounts must not be used.

Instead, to request an SPL Token transfer, the spl-token field must be used to specify an SPL Token mint, from which the associated token address of the recipient must be derived.
Amount

A single amount field is allowed as an optional query parameter. The value must be a non-negative integer or decimal number of "user" units. For SOL, that's SOL and not lamports. For tokens, use uiAmountString and not amount.

0 is a valid value. If the value is a decimal number less than 1, it must have a leading 0 before the .. Scientific notation is prohibited.

If a value is not provided, the wallet must prompt the user for the amount. If the number of decimal places exceed what's supported for SOL (9) or the SPL Token (mint specific), the wallet must reject the URL as malformed.
SPL Token

A single spl-token field is allowed as an optional query parameter. The value must be the base58-encoded public key of an SPL Token mint account.

If the field is provided, the Associated Token Account convention must be used, and the wallet must include a TokenProgram.Transfer or TokenProgram.TransferChecked instruction as the last instruction of the transaction.

If the field is not provided, the URL describes a native SOL transfer, and the wallet must include a SystemProgram.Transfer instruction as the last instruction of the transaction instead.

The wallet must derive the ATA address from the recipient and spl-token fields. Transfers to auxiliary token accounts are not supported.
Reference

Multiple reference fields are allowed as optional query parameters. The values must be base58-encoded 32 byte arrays. These may or may not be public keys, on or off the curve, and may or may not correspond with accounts on Solana.

If the values are provided, the wallet must include them in the order provided as read-only, non-signer keys to the SystemProgram.Transfer or TokenProgram.Transfer/TokenProgram.TransferChecked instruction in the payment transaction. The values may or may not be unique to the payment request, and may or may not correspond to an account on Solana.

Because Solana validators index transactions by these account keys, reference values can be used as client IDs (IDs usable before knowing the eventual payment transaction). The getSignaturesForAddress RPC method can be used locate transactions this way.
Label

A single label field is allowed as an optional query parameter. The value must be a URL-encoded UTF-8 string that describes the source of the transfer request.

For example, this might be the name of a brand, store, application, or person making the request. The wallet should URL-decode the value and display the decoded value to the user.
Message

A single message field is allowed as an optional query parameter. The value must be a URL-encoded UTF-8 string that describes the nature of the transfer request.

For example, this might be the name of an item being purchased, an order ID, or a thank you note. The wallet should URL-decode the value and display the decoded value to the user.
Memo

A single memo field is allowed as an optional query parameter. The value must be a URL-encoded UTF-8 string that must be included in an SPL Memo instruction in the payment transaction.

The wallet must URL-decode the value and should display the decoded value to the user. The memo will be recorded by validators and should not include private or sensitive information.

If the field is provided, the wallet must include a MemoProgram instruction as the second to last instruction of the transaction, immediately before the SOL or SPL Token transfer instruction, to avoid ambiguity with other instructions in the transaction.
Examples
URL describing a transfer request for 1 SOL.

solana:mvines9iiHiQTysrwkJjGf2gb9Ex9jXJX8ns3qwf2kN?amount=1&label=Michael&message=Thanks%20for%20all%20the%20fish&memo=OrderId12345

URL describing a transfer request for 0.01 USDC.

solana:mvines9iiHiQTysrwkJjGf2gb9Ex9jXJX8ns3qwf2kN?amount=0.01&spl-token=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v

URL describing a transfer request for SOL. The user must be prompted for the amount.

solana:mvines9iiHiQTysrwkJjGf2gb9Ex9jXJX8ns3qwf2kN&label=Michael

Specification: Transaction Request

A Solana Pay transaction request URL describes an interactive request for any Solana transaction.

solana:<link>

The request is interactive because the parameters in the URL are used by a wallet to make an HTTP request to compose a transaction.
Link

A single link field is required as the pathname. The value must be a conditionally URL-encoded absolute HTTPS URL.

If the URL contains query parameters, it must be URL-encoded. Protocol query parameters may be added to this specification. URL-encoding the value prevents conflicting with protocol parameters.

If the URL does not contain query parameters, it should not be URL-encoded. This produces a shorter URL and a less dense QR code.

In either case, the wallet must URL-decode the value. This has no effect if the value isn't URL-encoded. If the decoded value is not an absolute HTTPS URL, the wallet must reject it as malformed.
GET Request

The wallet should make an HTTP GET JSON request to the URL. The request should not identify the wallet or the user.

The wallet should make the request with an Accept-Encoding header, and the application should respond with a Content-Encoding header for HTTP compression.

The wallet should display the domain of the URL as the request is being made.
GET Response

The wallet must handle HTTP client error, server error, and redirect responses. The application must respond with these, or with an HTTP OK JSON response with a body of

{"label":"<label>","icon":"<icon>"}

The <label> value must be a UTF-8 string that describes the source of the transaction request. For example, this might be the name of a brand, store, application, or person making the request.

The <icon> value must be an absolute HTTP or HTTPS URL of an icon image. The file must be an SVG, PNG, or WebP image, or the wallet must reject it as malformed.

The wallet should not cache the response except as instructed by HTTP caching response headers.

The wallet should display the label and render the icon image to user.
POST Request

The wallet must make an HTTP POST JSON request to the URL with a body of

{"account":"<account>"}

The <account> value must be the base58-encoded public key of an account that may sign the transaction.

The wallet should make the request with an Accept-Encoding header, and the application should respond with a Content-Encoding header for HTTP compression.

The wallet should display the domain of the URL as the request is being made. If a GET request was made, the wallet should also display the label and render the icon image from the response.
POST Response

The wallet must handle HTTP client error, server error, and redirect responses. The application must respond with these, or with an HTTP OK JSON response with a body of

{"transaction":"<transaction>"}

The <transaction> value must be a base64-encoded serialized transaction. The wallet must base64-decode the transaction and deserialize it.

The application may respond with a partially or fully signed transaction. The wallet must validate the transaction as untrusted.

If the transaction signatures are empty:

    The application should set the feePayer to the account in the request, or the zero value (new PublicKey(0) or new PublicKey("11111111111111111111111111111111")).
    The application should set the recentBlockhash to the latest blockhash, or the zero value (new PublicKey(0).toBase58() or "11111111111111111111111111111111").
    The wallet must ignore the feePayer in the transaction and set the feePayer to the account in the request.
    The wallet must ignore the recentBlockhash in the transaction and set the recentBlockhash to the latest blockhash.

If the transaction signatures are nonempty:

    The application must set the feePayer to the public key of the first signature.
    The application must set the recentBlockhash to the latest blockhash.
    The application must serialize and deserialize the transaction before signing it. This ensures consistent ordering of the account keys, as a workaround for this issue.
    The wallet must not set the feePayer and recentBlockhash.
    The wallet must verify the signatures, and if any are invalid, the wallet must reject the transaction as malformed.

The wallet must only sign the transaction with the account in the request, and must do so only if a signature for the account in the request is expected.

If any signature except a signature for the account in the request is expected, the wallet must reject the transaction as malicious.

The application may also include an optional message field in the response body:

{"message":"<message>","transaction":"<transaction>"}

The <message> value must be a UTF-8 string that describes the nature of the transaction response.

For example, this might be the name of an item being purchased, a discount applied to the purchase, or a thank you note. The wallet should display the value to the user.

The wallet and application should allow additional fields in the request body and response body, which may be added by future specification.
Example
URL describing a transaction request.

solana:https://example.com/solana-pay

URL describing a transaction request with query parameters.

solana:https%3A%2F%2Fexample.com%2Fsolana-pay%3Forder%3D12345

GET Request

GET /solana-pay?order=12345 HTTP/1.1
Host: example.com
Connection: close
Accept: application/json
Accept-Encoding: br, gzip, deflate

GET Response

HTTP/1.1 200 OK
Connection: close
Content-Type: application/json
Content-Length: 62
Content-Encoding: gzip

{"label":"Michael Vines","icon":"https://example.com/icon.svg"}

POST Request

POST /solana-pay?order=12345 HTTP/1.1
Host: example.com
Connection: close
Accept: application/json
Accept-Encoding: br, gzip, deflate
Content-Type: application/json
Content-Length: 57

{"account":"mvines9iiHiQTysrwkJjGf2gb9Ex9jXJX8ns3qwf2kN"}

POST Response

HTTP/1.1 200 OK
Connection: close
Content-Type: application/json
Content-Length: 298
Content-Encoding: gzip

{"message":"Thanks for all the fish","transaction":"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAECC4JMKqNplIXybGb/GhK1ofdVWeuEjXnQor7gi0Y2hMcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQECAAAMAgAAAAAAAAAAAAAA"}

Overview

Learn how to integrate transaction requests into your payments flow.

With transaction requests, it’s now possible to bring any Solana transaction into the real world through an interactive request between a checkout app and a mobile wallet, enabling NFT minting, dynamic discounts, tokenized loyalty programs, and so much more. Here’s how it works:

transaction request flow
Start with a guide
Taking payments IRL with Solana Pay

Learn to take payments both online and IRL with Solana Pay!
Use cases

Transaction requests elevate the power of a simple purchase, allowing any transaction that’s possible on Solana. Here are a some initial use cases for devs to explore:

    Merchants can enact a true bi-directional communication channel with customers. They can atomically mint an NFT or transfer loyalty tokens in the transaction at the point of sale.
    Composable DeFi transactions involving borrowing, swaps, escrow, privacy, and more, can occur at the point of sale, enabling refunds, chargebacks, insurance, buy-now-pay-later, discounts, rewards, and yield generation.
    Merchants can opt to pay for transaction fees, token account creation, and NFT minting on their customers’ behalf so they don't need SOL in their wallet, reducing the friction of interacting with the Solana ecosystem.
    Merchants can decline to respond to a transaction request, which could be used to allow permissioned payments, such as in cases where authentication is required for compliance.
    Think beyond payments. Merchants and brands can create dynamic experiences that send tokens, invitations, and gifts to customers. Check out mtnPay’s Booth app which mints 1:1 NFTs for customers using transaction requests.

Create a transaction request

This section describes how a merchant can integrate Solana Pay transaction requests into their payments flow.

This guide walks through an example of how you can configure a server to respond to a Solana Pay transaction request to initiate a simple native SOL transfer.

A complete example can be found here.
Requirements

For this example, we'll be building our server using NextJS API routes. There are no rigid requirements on where your server is deployed and what technologies or languages are used.
1. Set-up Solana Pay

Install Solana Pay libraries to access the API from your application:

npm

npm install @solana/pay @solana/web3.js bignumber.js @solana/spl-token --save

yarn

yarn add @solana/pay @solana/web3.js bignumber.js @solana/spl-token

1. Create the handler

The handler is the entry point of the API, and "handles" all incoming requests.

const index = async (request, response) => {
    // We set up our handler to only respond to `GET` and `POST` requests.
    if (request.method === 'GET') return get(request, response);
    if (request.method === 'POST') return post(request, response);

    throw new Error(`Unexpected method ${request.method}`);
};

2. The link

A Solana Pay transaction request URL describes an interactive request for any Solana transaction.

solana:<link>

A single link field is required as the pathname. The value must be an absolute HTTPS URL. If the URL contains query parameters, it must be URL-encoded.

solana:https://example.solanapay.com

Our server https://example.solanapay.com needs to be configured to respond correctly to GET and POST requests.
3. The GET request

The first part of the transaction request spec is for the wallet to make a GET request to the specified link.

const get = async (request, response) => {
    const label = 'Exiled Apes Academy';
    const icon = 'https://exiledapes.academy/wp-content/uploads/2021/09/X_share.png';

    response.status(200).send({
        label,
        icon,
    });
};

The GET endpoint should respond with two properties. label describes the source of the transaction request. For example, this might be the name of a brand, store, application, or person making the request. icon must be an SVG, PNG, or WebP image. The icon and label will be displayed to the user.
4. The POST request

The second part of the transaction request spec is the POST request.

import { clusterApiUrl, Connection, Keypair, PublicKey, VersionedTransaction } from '@solana/web3.js';
import BigNumber from 'bignumber.js';
import { createTransferCheckedInstruction, getAccount, getAssociatedTokenAddress, getMint } from '@solana/spl-token';
import { TEN } from '@solana/pay';

const splToken = new PublicKey(process.env.USDC_MINT);
const MERCHANT_WALLET = new PublicKey(process.env.MERCHANT_WALLET);

const post = async (request, response) => {
    // Account provided in the transaction request body by the wallet.
    const accountField = request.body?.account;
    if (!accountField) throw new Error('missing account');

    const sender = new PublicKey(accountField);

    // create spl transfer instruction
    const splTransferIx = await createSplTransferIx(sender, connection);

    // create the transaction
    const transaction = new VersionedTransaction(
        new TransactionMessage({
            payerKey: sender,
            recentBlockhash: '11111111111111111111111111111111',
            // add the instruction to the transaction
            instructions: [splTransferIx]
        }).compileToV0Message()
    )

    const serializedTransaction = transaction.serialize()

    const base64Transaction = Buffer.from(serializedTransaction).toString('base64');
    const message = 'Thank you for your purchase of ExiledApe #518';

    response.status(200).send({ transaction: base64Transaction, message });
};

The wallet will make a POST request to the specified link with the user's wallet address as the account property of the request body.

The POST endpoint should respond with a base64-encoded transaction. You can return an optional message property to describe the transaction.
4.1 The transaction response

The transaction that's returned can be -- anything. It doesn't even need to be a payment. For example, it could be a transaction to receive a gift or an invitation from the merchant for scanning a wallet.
Some ideas of what transactions you can do.

    Merchants get an atomic bidirectional communication channel with customers. They can mint an NFT or transfer loyalty reward tokens in the transaction.
    Merchants could potentially see what tokens a user has, accepting and denominating payment in any of them.
    Merchants can pay for transactions on their user's behalf so they don't need SOL in a wallet.
    Merchants can return an error from the server to decline to respond with a transaction. This could be used to allow permissioned payments.
    Payments can be directed to escrow-like programs, enabling things like refunds, chargebacks, and other return mechanisms.
    DeFi transactions could be bridged to all kinds of web2 / IRL portals.
    Wallets can retrieve other information, or merchants can pass it to them, like an icon to display, or other fields in the JSON response.
    It doesn't even need to be a payment. Merchants could send tokens, invitations, gifts to customers that connect a wallet, perhaps one that meets some criteria, such as possessing an NFT.

async function createSplTransferIx(sender, connection) {
    const senderInfo = await connection.getAccountInfo(sender);
    if (!senderInfo) throw new Error('sender not found');

    // Get the sender's ATA and check that the account exists and can send tokens
    const senderATA = await getAssociatedTokenAddress(splToken, sender);
    const senderAccount = await getAccount(connection, senderATA);
    if (!senderAccount.isInitialized) throw new Error('sender not initialized');
    if (senderAccount.isFrozen) throw new Error('sender frozen');

    // Get the merchant's ATA and check that the account exists and can receive tokens
    const merchantATA = await getAssociatedTokenAddress(splToken, MERCHANT_WALLET);
    const merchantAccount = await getAccount(connection, merchantATA);
    if (!merchantAccount.isInitialized) throw new Error('merchant not initialized');
    if (merchantAccount.isFrozen) throw new Error('merchant frozen');

    // Check that the token provided is an initialized mint
    const mint = await getMint(connection, splToken);
    if (!mint.isInitialized) throw new Error('mint not initialized');

    // You should always calculate the order total on the server to prevent
    // people from directly manipulating the amount on the client
    let amount = calculateCheckoutAmount();
    amount = amount.times(TEN.pow(mint.decimals)).integerValue(BigNumber.ROUND_FLOOR);

    // Check that the sender has enough tokens
    const tokens = BigInt(String(amount));
    if (tokens > senderAccount.amount) throw new Error('insufficient funds');

    // Create an instruction to transfer SPL tokens, asserting the mint and decimals match
    const splTransferIx = createTransferCheckedInstruction(
        senderATA,
        splToken,
        merchantATA,
        sender,
        tokens,
        mint.decimals
    );

    // Create a reference that is unique to each checkout session
    const references = [new Keypair().publicKey];

    // add references to the instruction
    for (const pubkey of references) {
        splTransferIx.keys.push({ pubkey, isWritable: false, isSigner: false });
    }

    return splTransferIx;
}

For our example, we create a simple transfer for a SPL token, serialize the transaction, and base64 encode it.

Create a transfer request

This section describes how a merchant can integrate Solana Pay transfer requests into their payments flow. It shows how to create a payment request link, encode it into a QR code, find the transaction, and validate it.

This guide walks through an example of a QR code-based Point of Sale system that accepts payments via Solana Pay.

The complete example code can be found here.
Requirements

Before you can receive payments, you'll need to obtain a native SOL address. This doesn't cost anything, and you can use any wallet to get started.

If you want to receive USDC or another SPL token on Solana, you'll need to create a token account, which may require a small amount of SOL.

One way to do both is to use Coinbase, which will provide a native SOL deposit address and an associated USDC token account to receive payments.
1. Set up Solana Pay

Install the packages and import them in your code.

npm

npm install @solana/pay @solana/web3.js bignumber.js --save

yarn

yarn add @solana/pay @solana/web3.js bignumber.js

1.1 Import necessary modules

Import the modules used to work with Solana Pay.

import { Cluster, clusterApiUrl, Connection, PublicKey } from '@solana/web3.js';
import { encodeURL, createQR } from '@solana/pay';
import BigNumber from 'bignumber.js';

1.2 Establish a connection

When working on Solana, you will need to connect to the network. For our example, we will connect to devnet.
Establish a connection to the devnet network

async function main() {
    // Variable to keep state of the payment status
    let paymentStatus: string;

    // Connecting to devnet for this example
    console.log('1. ✅ Establish connection to the network');
    const connection = new Connection(clusterApiUrl('devnet'), 'confirmed');
}

2. Create a payment request link

Solana Pay uses a standard URL scheme across wallets for native SOL and SPL Token payments. Several parameters are encoded within the link representing an intent to collect payment from a customer.
Create a payment request link with a recipient, amount, label, message , memo and reference.

// -- snippet -- //

/**
 * Simulate a checkout experience
 *
 * Recommendation:
 * `amount` and `reference` should be created in a trusted environment (server).
 * The `reference` should be unique to a single customer session,
 * and will be used to find and validate the payment in the future.
 *
 */
console.log('2. 🛍 Simulate a customer checkout \n');
const recipient = new PublicKey('MERCHANT_WALLET');
const amount = new BigNumber(20);
const reference = new Keypair().publicKey;
const label = 'Jungle Cats store';
const message = 'Jungle Cats store - your order - #001234';
const memo = 'JC#4098';

/**
 * Create a payment request link
 *
 * Solana Pay uses a standard URL scheme across wallets for native SOL and SPL Token payments.
 * Several parameters are encoded within the link representing an intent to collect payment from a customer.
 */
console.log('3. 💰 Create a payment request link \n');
const url = encodeURL({ recipient, amount, reference, label, message, memo });

See full code snippet
Optional. SPL token transfer

For SPL Token transfers, use the spl-token parameter. The spl-token is the mint address of the SPL token.
See code snippet

/**
 * Simulate a checkout experience with an SPL token
 */
console.log('2. 🛍 Simulate a customer checkout \n');
const splToken = new PublicKey('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');

/**
 * Create a payment request link
 *
 * Solana Pay uses a standard URL scheme across wallets for native SOL and SPL Token payments.
 * Several parameters are encoded within the link representing an intent to collect payment from a customer.
 */
console.log('3. 💰 Create a payment request link \n');
const url = encodeURL({
    recipient,
    amount,
    splToken,
    reference,
    label,
    message,
    memo,
});

3. Encode link into a QR code

Now that you've created a payment link, you need a way to show it to your customers.
Encode the link into a QR code.

// -- snippet -- //

/**
 * Create a payment request link
 *
 * Solana Pay uses a standard URL scheme across wallets for native SOL and SPL Token payments.
 * Several parameters are encoded within the link representing an intent to collect payment from a customer.
 */
console.log('3. 💰 Create a payment request link \n');
const url = encodeURL({ recipient, amount, reference, label, message, memo });

// encode URL in QR code
const qrCode = createQR(url);


qr code
3.1 Add the QR code to your payment page

The QR code needs to be visible on your payment page.
Add the QR code to an element on the payment page

// -- snippet -- //

console.log('3. 💰 Create a payment request link \n');
const url = encodeURL({ recipient, amount, reference, label, message, memo });

// encode URL in QR code
const qrCode = createQR(url);

// get a handle of the element
const element = document.getElementById('qr-code');

// append QR code to the element
qrCode.append(element);

Instructions on integrating with your framework of choice can be found here.
4. Show a payment status page

With the payment link set up and shown to the customer, you will need to ensure that the customer has paid for the item before shipping their order.

When a customer approves the payment request in their wallet, this transaction exists on-chain. You can use any references encoded into the payment link to find the exact transaction on-chain.
Use findReference to find the on-chain transaction. Provide a reference to this function that identifies the transaction associated with the order.

// -- snippet -- //

/**
 * Simulate wallet interaction
 *
 * This is only for example purposes. This interaction will be handled by a wallet provider
 */
console.log('4. 🔐 Simulate wallet interaction \n');
simulateWalletInteraction(connection, url);

// Update payment status
paymentStatus = 'pending';

/**
 * Wait for payment to be confirmed
 *
 * When a customer approves the payment request in their wallet, this transaction exists on-chain.
 * You can use any references encoded into the payment link to find the exact transaction on-chain.
 * Important to note that we can only find the transaction when it's **confirmed**
 */
console.log('\n5. Find the transaction');
const signatureInfo = await findReference(connection, reference, { finality: 'confirmed' });

// Update payment status
paymentStatus = 'confirmed';

Note: The findReference function uses confirmed as the default finality value. This can, on rare occasions, result in a transaction that is not fully complete. For full finality, use finalized. This can result in slower transaction completion.

See full code snippet
4.1 Retries

If a transaction with the given reference can't be found, the findReference function will throw an error. There are a few reasons why this could be:

    Transaction is not yet confirmed
    Customer is yet to approve/complete the transaction

You can implement a polling strategy to query for the transaction periodically.

// -- snippet -- //

let signatureInfo: ConfirmedSignatureInfo;

return new Promise((resolve, reject) => {
    /**
     * Retry until we find the transaction
     *
     * If a transaction with the given reference can't be found, the `findReference`
     * function will throw an error. There are a few reasons why this could be a false negative:
     *
     * - Transaction is not yet confirmed
     * - Customer is yet to approve/complete the transaction
     *
     * You can implement a polling strategy to query for the transaction periodically.
     */
    const interval = setInterval(async () => {
        console.log('Checking for transaction...', count);
        try {
            signatureInfo = await findReference(connection, reference, { finality: 'confirmed' });
            console.log('\n 🖌  Signature found: ', signatureInfo.signature);
            clearInterval(interval);
            resolve(signatureInfo);
        } catch (error: any) {
            if (!(error instanceof FindReferenceError)) {
                console.error(error);
                clearInterval(interval);
                reject(error);
            }
        }
    }, 250);
});

See full code snippet
4.2 Validating the transaction

Once the findReference function returns a signature, it confirms that a transaction that references the order has been recorded on-chain. But it doesn't guarantee that a valid transfer with the expected amount and recipient happened.
validateTransfer allows you to validate that the transaction signature found matches the transaction that you expected.

// -- snippet -- //

/**
 * Validate transaction
 *
 * Once the `findReference` function returns a signature,
 * it confirms that a transaction with reference to this order has been recorded on-chain.
 *
 * `validateTransfer` allows you to validate that the transaction signature
 * found matches the transaction that you expected.
 */
console.log('\n6. 🔗 Validate transaction \n');

try {
    await validateTransfer(connection, signature, { recipient: MERCHANT_WALLET, amount });

    // Update payment status
    paymentStatus = 'validated';
    console.log('✅ Payment validated');
    console.log('📦 Ship order to customer');
} catch (error) {
    console.error('❌ Payment failed', error);
}

See full code snippet
Best practices

We recommend handling a customer session in a secure environment. Building a secure integration with Solana Pay requires a payment flow as follows:

best practices diagram

    Customer goes to the payment page
    Merchant frontend (client) sends order information to the backend
    Merchant backend (server) generates a reference public key and stores it in a database with the expected amount for the shopping cart / pending purchase (unique to each customer's checkout session).
    Merchant backend redirects the user to the confirmation page with the generated reference public key.
    The confirmation page redirects to the merchant with the transaction signature.
    Merchant backend checks that the transaction is valid for the checkout session by validating the transaction with the reference and amount stored in step 3.

The steps outlined above prevents:

    A different transaction from being used to trick the merchant
    The frontend from being manipulated to show a confirmed transaction

Handle a transfer request

This section describes how a wallet provider can support payment links in their wallet. It shows how to parse the payment URL and create a transaction from it.

This guide walks through an example implementation for wallet providers. The purpose of this is to make it easy for wallets to implement the protocol correctly.
1. Set up Solana Pay

Install the packages and import them in your code.

npm

npm install @solana/pay @solana/web3.js --save

yarn

yarn add @solana/pay @solana/web3.js

2. Parse payment request link

As a wallet provider, you will have to parse the received URL to extract the parameters. For more information on the URL format, please see the specification.
Parse the URL to retrieve all possible fields:

import { parseURL } from '@solana/pay';

/**
 * For example only
 *
 * The URL that triggers the wallet interaction; follows the Solana Pay URL scheme
 * The parameters needed to create the correct transaction is encoded within the URL
 */
const url =
    'solana:mvines9iiHiQTysrwkJjGf2gb9Ex9jXJX8ns3qwf2kN?amount=0.01&reference=82ZJ7nbGpixjeDCmEhUcmwXYfvurzAgGdtSMuHnUgyny&label=Michael&message=Thanks%20for%20all%20the%20fish&memo=OrderId5678';
const { recipient, amount, splToken, reference, label, message, memo } = parseURL(url);

See full code snippet
3. Create transaction

Use the createTransaction function to create a transaction with the parameters from the parseURL function with an additional payer.

The payer should be the public key of the current users' wallet.
Create transaction reference implementation

import { parseURL, createTransaction } from '@solana/pay';

const url =
    'solana:mvines9iiHiQTysrwkJjGf2gb9Ex9jXJX8ns3qwf2kN?amount=0.01&reference=82ZJ7nbGpixjeDCmEhUcmwXYfvurzAgGdtSMuHnUgyny&label=Michael&message=Thanks%20for%20all%20the%20fish&memo=OrderId5678';
const { recipient, amount, splToken, reference, label, message, memo } = parseURL(url);

/**
 * Create the transaction with the parameters decoded from the URL
 */
const payer = CUSTOMER_WALLET.publicKey;
const tx = await createTransfer(connection, payer, { recipient, amount, reference, memo });

See full code snippet

This transaction should represent the original intent of the payment request link. The example implementation walks through the steps on how to construct the transaction:

Native SOL transfer

    Check that the payer and recipient accounts exist
    Check the payer and recipient are valid native accounts
    Check the payer has enough lamports for the transfer
    Create an instruction to transfer native SOL
    If references were included, add them to the instruction
    If a memo was included, create an instruction for the memo program

SPL token transfer

    Check that the payer and recipient accounts exist
    Check the token provided is an initialized mint
    Check the payer and recipient's Associated Token Account (ATA) exists
    Check the payer has enough lamports for the transfer
    Create an instruction to transfer SPL tokens
    If references were included, add them to the instruction
    If a memo was included, create an instruction for the memo program

4. Complete transaction

With the transaction formed. The user must be prompted to approve the transaction.

The label and message should be shown to the user, as it gives added context to the user on the transaction.
Finally, use sendAndConfirmTransaction to complete the transaction.

const { recipient, message, memo, amount, reference, label } = parseURL(url);
console.log('label: ', label);
console.log('message: ', message);

/**
 * Create the transfer with the parameters decoded from the URL
 */
const tx = await createTransfer(connection, payer, { recipient, amount, reference, memo });

/**
 * Send the transaction to the network
 */
sendAndConfirmTransaction(connection, tx, [CUSTOMER_WALLET]);

See full code snippet
Deep linking

Wallet providers building for mobile or wearable devices are encouraged to register their app as a handler for the Solana Pay URL scheme solana:.

For example, when a payment request is presented as a QR code, the payer should ideally be able to read the code using the native scanning capability of their device and have the appropriate wallet open with the transaction prefilled.

URLs can be embedded in the environment in web pages, QR codes, NFC tags and potential new formats. To avoid inadvertent transfer of tokens, care must be taken when designing wallets to ensure that transactions cannot accidentally be triggered and sent.

@solana/pay
Index
Classes

CreateTransferError
FetchTransactionError
FindReferenceError
ParseURLError

    ValidateTransferError

Functions

createQR
createTransfer
encodeURL
fetchTransaction
findReference
parseURL

    validateTransfer

Interfaces

CreateTransferFields
TransactionRequestURL
TransactionRequestURLFields
TransferRequestURL
TransferRequestURLFields

    ValidateTransferFields

Type Aliases

Amount
Label
Link
Memo
Message
Recipient
Reference
References

    SPLToken

Type Aliases
Amount
Amount: BigNumber

amount in the Solana Pay spec.
Label
Label: string

label in the Solana Pay spec.
Link
Link: URL

link in the Solana Pay spec.
Memo
Memo: string

memo in the Solana Pay spec.
Message
Message: string

message in the Solana Pay spec.
Recipient
Recipient: PublicKey

recipient in the Solana Pay spec.
Reference
Reference: PublicKey

reference in the Solana Pay spec.
References
References: Reference | Reference[]

reference in the Solana Pay spec.
SPLToken
SPLToken: PublicKey

spl-token in the Solana Pay spec.